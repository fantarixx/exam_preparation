### Compilation
> 10. Компиляция, этапы, ошибки компиляци

Программы состоят из файлов. Для чего прграмму разбивают на файлы:
- Логическое разбиение на модули (легче работать с кодом)
- Повторное использование некоторых кусков кода
- Ускорение процесса компиляции
- Небольшие файлы проще читать и редактировать
- Есть два типа файлов
	- Заголовочные (*.h , *.hpp)
	- С исходным кодом (*.cpp)

> Заголовочные файлы в языке программирования C++ содержат:
> - Function declaration & definition
> - Variable declaration
> - Type declaration
> - Static variable definition & declaration
> - Class and structs definition & declaration 
> - …
> 
> Пример заголовочного файла:
> ```Cpp
> #pragma once
> 
> int add(int a, int b);
> 
> const static float PI = 3.14;
> 
> int some_value;
> ```
> 
> Файлы кода содержат исходный код, написанный на объектно-ориентированном языке программирования C++.

<br>

# <u>Определения:</u>
1. ***<u>Трансляция</u>*** <mark>translation</mark>- преобразование программы, представленной на одном из языков программирования (**исходный язык** <mark>source language</mark>), в программу на другой язык (**целевой язык** target <mark>language</mark>) и, в определённом смысле, равносильную первой.
   
2. ***<u>Транслятор</u>*** <mark>translator</mark> - программа или устройство, которое выполняет трансляцию.
   
3. ***<u>Исходный код</u>*** <mark>source code</mark> - фрагмент текста, написанный на исходном языке для некоторого транслятора, “программа” как текст.
   
4. ***<u>Единица трансляции</u>*** <mark>translation unit</mark> - файл исходного кода, обрабатываемый транслятором как единое целое. В случае языка C++ единица трансляции (файл .cpp) является модулем.
   
5. ***<u>Интерпретация</u>*** <mark>interpreting</mark> - построчный анализ, обработка и выполнение исходного кода программы или запроса.
   
6. ***<u>Интерпретатор</u>*** <mark>interpreter</mark>:
	 - программа или устройство, которое выполняет интерпретацию.
	 - транслятор, целевым языком которого является множество действий.  
	   
7. ***<u>Компиляция</u>*** <mark>compilation</mark>:
	  - преобразование программы, представленной на одном из языков програмирования в программу на более низком коде, близком к машинному, который может быть непосредственно выполнен процессором.
	  - трансляция, результатом которой является машинный код, который может  быть непосредственно выполнен процессором. 
	  - трансляция, результатом которой является файл на нектором целевом языке. В ряде случаев этот файл готов к запуску в некоторой среде исполнения (операционной системе или на виртуальной машине). В дургих случаях требуется компановка (процесс связывания с другими фрагментами кода).
	
8. ***<u>Компилятор</u>*** <mark>compiler</mark> - программа или устройство, которое выполняет компиляцию.
>Если для компилятора помимо собственно целевого языка имеет значение способ оформления результирующих файлов и иные особенности операционной среды (обычно задаваемые выбором целевой ОС), то говорят о **целевой платформе**. Если целевая платформа не совпадает (не является надмножеством) платформы, на которой запущен сам компилятор, то процесс такой компиляции называется **кросс-компиляцией** (например, на GNU/Linux компилируется код, который будет затем запускаться на Windows).

9. ***<u>Раздельная компиляция</u>*** <mark>separate compilation</mark> - компиляция единиц трансляции по отдельности независимо друг от друга (в произвольном порядке, в том числе параллельно). Какая-то часть из них может быть откомпилирована заранее. В случае C++ это означает независимую компиляцию разных .cpp файлов, включенных в проект. Когда все единицы трансляции скомпилированы, можно выполнить их компоновку в конечный продукт — например, исполняемый файл.
   
10. ***<u>Ассемблер</u>*** <mark>assembler</mark> - транслятор, исходным языком которого является стандартизованная текстовая форма машинного кода (удобного для человека, - **ассемблерный код** <mark>assembly</mark>), а целевым языком — машинный код.
> Ассемблер можно считать видом компилятора, но традиционно термин “компилятор” применяется только по отношению к трансляторам с исходных языков высокого уровня.

11. ***<u>Дизассемблер</u>*** <mark>disassembler</mark> - ранслятор, исходным языком которого является машинный код, а целевым языком — ассемблерный код. Дизассемблеры, как правило, принимают на вход исполняемые файлы и библиотеки в машинном коде.

12. ***<u>Объектный файл</u>*** <mark>object</mark> - результат работы компилятора в случае использования отдельной программы-компоновщика. Как правило, содержит специальным образом оформленный машинный код (**объектный код** <mark>object code</mark>).
> **“Object code”** тоже можно перевести как “целевой код”, и он действительно является целевым для компилятора. Однако такой перевод может вызвать путаницу с точки зрения разделения “целевого языка” вообще или фрагмента программы на этом языке и промежуточного файла, принимаемого компоновщиком (см. ниже) — “объекта”.
> 
> Исторически слово “object”, вероятно, связано с языком [BCPL](https://ru.wikipedia.org/wiki/BCPL), который можно считать предком языка C. Компилятор BCPL транслировал программы на BCPL в файлы на специальном промежуточном языке низкого уровня [O-code](https://en.wikipedia.org/wiki/O-code) (“object code” — “целевой код”), которые уже затем могли транслироваться в исполняемые файлы для конкретных ОС и процессоров отдельными трансляторами. Такой подход облегчал перенос компилятора на новые системы: сам компилятор можно было не трогать, достаточно было обновить (или написать новый) транслятор O-code. [Данный подход](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B9%D1%82-%D0%BA%D0%BE%D0%B4) затем применялся неоднократно (например, для Pascal, Basic, Java, .NET).

13. ***<u>Машинный код</u>*** <mark>machine code</mark> - язык, интерпретатором которого является некоторый процессор (“машина”).

14. ***<u>Компановка</u>*** <mark>linking</mark> - построение готового к запуску исполняемого файла, либо стандартным образом оформленной библиотеки в машинном коде из набора объектных файлов, библиотек в машинном коде, а также любых дополнительных данных. 

15. ***<u>Компоновщик</u>*** <mark>linker</mark> - программа, выполняющая компановку.

16. ***<u>Исполняемый файл</u>*** <mark>executable</mark> - оформленная в виде файла стандартного формата (для определённой ОС) программа в машинном коде, которую можно немедленно запустить на исполнение.
> - В ОС Windows исполняемые файлы традиционно помечаются разрешением **exe**.
>  - В maxOC и iOS используется формат **Mach-O**.
>  - В Linux нет расширений файлов, но для удобства исполняемые файлы помечаются разрешением **exe**.

17. ***<u>Модуль</u>*** <mark>module</mark>:
	- Специальным образом оформленная единица исходного кода, задающая свою область видимости. Во многих языках (включая C, с той поправкой, что интерфейс модуля предоставляется в виде отдельного заголовочного файла) совпадает с файлом исходного кода и единицей трансляции. Такой модуль может иметь имя, доступное из программы (например, юнит в Pascal, в C — просто имя заголовочного файла, используемое в директиве include).
	- Единица трансляции.
	- В операционных системах: стандартным образом оформленный машинный код (набор процедур), возможно, с внедрёнными данными - **ресурсами** <mark>resources</mark>. Исполняемый файл и динамически связываемая библиотека — примеры модулей.

18. ***<u>Сборка</u>*** <mark>building</mark> - полный многоэтапный процесс порождения исполняемых файлов (модулей) из файлов исходного кода, библиотек и файлов ресурсов.
> Необходимый для сборки конкретный набор программ называют (это распространённый жаргонизм) **тулчейном** <mark>toolchain</mark>. Обычно это компилятор и компоновщик. Нередко в состав тулчейна добавляют отладчик. Естественно, отладчик не задействуется в процессе сборки непосредственно, однако, если мы хотим эффективно применять некоторый отладчик к результирующему машинному коду, то поддержка этого отладчика должна быть заложена уже на этапе сборки. Конкретные реализации стандартных библиотек также могут включаться в тулчейн (просто потому, что любая реализация языка обязана поддерживать его стандартную библиотеку).

19. ***<u>Объявление</u>*** <mark>declaration</mark> - языковая конструкция, заявляющая о наличии среди используемых в сборке единиц трансляции и библиотек некоторой сущности (глобальной переменной, функции, типа) и предоставляющая компилятору необходимый минимум сведений об этой сущности.
> В частности, объявление функции состоит из заголовка функции, что позволяет компилятору оформить вызов функции в объектном коде. А уже на этапе компоновки будет достаточно проставить реальный адрес вызываемой функции.

```Cpp
// declaration
int add(int a, int b);
```

20. ***<u>Определение</u>*** <mark>definition</mark> - полное описание некоторой сущности (переменной, функции, типа) на языке программирования.
```Cpp
//definition
int add(int a, int b) { return a + b; }
```

21. ***<u>Правило одного определения</u>*** <mark>one definition rule, ODR</mark> в C++:   
		1. Любая глобальная сущность может быть определена лишь однажды. <br>
		2. Любая локальная сущность может быть определена лишь однажды в своей области видимости.
> Программа, нарушающая первую часть ODR может быть скомпилирована без ошибок, но привести к ошибкам компоновки. Программа, нарушающая вторую часть ODR приведёт к ошибкам компиляции.

22. ***<u>Библиотека</u>*** <mark>library</mark> -  самостоятельный фрагмент кода, предназначенный для использования в составе другого ПО.
> Библиотека может существовать как в исходном коде, подключаемом во время компиляции и транслируемом вместе с кодом ПО, использующего библиотеку, так и в специально оформленном машинном коде (“модуле”), подключаемом либо во время компоновки (**статические библиотеки** <mark>static libraries</mark>), либо во время работы ПО (**динамически связываемые библиотеки** <mark>dynamically linked libraries, DLL</mark>, <mark>shared objects, SO</mark>).

23. ***<u>Точка входа</u>*** <mark>entry point</mark> - адрес в модуле (исполняемом файле или библиотеке), с которого можно начать выполнение кода.
> Адрес может иметь символическое имя, записанное в специальной таблице внутри модуля. Часто это имя просто совпадает с именем соответствующей функции в исходном коде. В C++ определена стандартная точка входа для исполняемых файлов — функция main.

# <u>Этапы трансляции</u>
| Основные этапы:                                                  | Пример                                                   |
|----------------------------------------------------------------------|----------------------------------------------------------|
| 1. Препроцессор<br>2. Компоновщик<br>3. Линковщик                   | ![Пример трансляции](./src/translation.png)          |

Компиляторы умеют запускать этапы трансляции по отдельности (на примере **clang**):
- ***clang++ -E*** - run *preprocess*
- ***clang++ -S*** - run *preprocess* and *compilation* steps
- ***clang++ -c*** - run *preprocess*, *compile*, and *assemble* steps
- ***clang++ --Xlinker*** - run *linker*

## Препроцессор
- **Язык препроцессора** – это специальный язык программирования, встроенный в C++.
- Лексический анализ кода.
- Команды языка препроцессор называют **директивами**, все директивы начинаются со знака #.
- Директива `#include` позволяет подключать заголовочные файлы к файлам кода.
- Препроцессор заменяет директиву `#include "bar.h"` на содержимое файла `bar.h`.
- Директивы препроцессора:
	<ol type="1">
		<li>`#define` и `#unded (__FILE__, __LINE__, …)`</li>
		<li>`#` and `##` operators.</li>
		<li>Условное включение (`#if`, `#ifdef`, `#ifndef`, `#elif`, `#else`, `#endif`).</li>
		<li>`#include`
			- `#include <filename>`
			- `#include "filename"`
		<li>`#pragma once`</li>
		<li>`#error`</li>
		<li>etc.</li>
 		</ol>
	
### Макросы
- ***Макросами*** в C++ называют инструкции препроцессора.
- Препроцессор C++ является самостоятельным языком, работающим с произвольными строками.
- Макросы можно использовать для определения функций.
> Препроцессор **“не знает”** про синтаксис C++.

***<u>Примеры:</u>***
1. Пример реализации функции `Max` через макрос.
	```Cpp
	#include <iostream>
	#define MAX(x, y) (x > y ? x : y) 
	int main() {
		// Some comment
		std::cout << MAX(10, 20) << std::endl;
		return 0;
	}
	```

	Запустим препроцессор для этого примера:
	`clang++ -E main.cpp`
	
	Результат выполнения:
	```
	content of iostream
	
	# 2 "main.cpp" 2
	
	int main() {
		std::cout << (10 > 20 ? 10 : 20) << std::endl;
		return 0;
	}
	```
2. Пример отлова ошибок в режиме `Debug`.
	```Cpp
	#ifdef __DEBUG__
		#define error_log(format, ...) printf("[ERROR] (%s:%d) " format "\n", __FILE__, __LINE__, ##__VA_ARGS__)
	#else
		#define error_log(format, ...)
	#endif
	
	int main() {
	error_log("fatal errro no: %d", 1);
	
	return 0;
	}
	```
3. Пример написания функции вывода информации через макрос.
	```Cpp
	#define log(type, format, ...) printf("[" type "] (%s:%d) " format "\n", __FILE__, __LINE__, ##__VA_ARGS__)
	
	#define log_error(...) log("ERORR", ##__VA_ARGS__ )
	#define log_info(...) log("INFO", ##__VA_ARGS__ )
	```

### Стражи
Рассмотрим ситуацию:
```Cpp
//1.h
#include "2.h"
#include "3.h"
#include "4.h"
...

//2.h
#include "3.h"
...

//main.cpp
#include "1.h"

int main() {
...
}
```
На этапе препроцесса в `main.cpp` подставется значение `1.h` и он будет выглядеть примерно так:
  
```
#include "3.h" -> (полный текст 3.h) ...
#include "3.h" -> (полный текст 3.h) 
#include "4.h" -> (полный текст 4.h)
...
int main() {  
...  
}
```
Как видно файл `3.h` включится 2 раза, а это - ошибка компиляции.
Этого можно избежать с помощью стражей:
- <u>Директива ***`#pragma`***</u>:
	- Особенности:
		1. **Зависимость от компилятора**: Каждый компилятор (GCC, Clang, MSVC и др.) интерпретирует `#pragma` по-своему.
		2. **Нестандартное поведение**: Директивы `#pragma` часто выходят за рамки стандарта языка, поэтому их использование может снизить переносимость кода.

	- Распространенные примеры:
		1. **`#pragma once`**: Предотвращает многократное включение одного файла заголовка.
			```Cpp
			#pragma once
			// Содержимое
			заголовочного файла
			```
		2. **`#pragma pack(n)`**: Управляет выравниванием данных в структурах (полезно для работы с бинарными протоколами или аппаратурой).
			> В **C++** ***"выравнивание"*** <mark>alignment</mark> — это процесс размещения данных в памяти таким образом, чтобы они соответствовали требованиям архитектуры процессора. Это важно для оптимизации работы с памятью и предотвращения штрафов за неправильный доступ.
			>
			> ***<u>Особенности:</u>***
			> 1. **Выравнивание данных:**  
		    > 	- Каждому типу данных соответствует свое требуемое выравнивание (например, `int` обычно выравнивается по 4 байтам, `double` — по 8).
			>	- Компилятор автоматически размещает переменные с учетом их выравнивания.
			> 2. **Проблема упаковки <mark>padding</mark>:**    
		    > 	- Структуры могут содержать "пустые" байты (паддинг), чтобы соответствовать требованиям выравнивания.
		    > 	- Например:
		    > 		```Cpp
		    > 		struct A {
		    > 			char c;  // 1 байт
		    > 			int i;   // 4 байта (но начнется с адреса, кратного 4)
			> 		};
		    > 		```	
		    > 		Здесь между `c` и `i` добавятся 3 байта паддинга.
		    > 3. **Оптимизация с `#pragma pack` и `alignas`:**
		    > 	- `#pragma pack(N)` уменьшает выравнивание, но может замедлить доступ к данным.
		    > 	- Пример с `#pragma pack`:
		    > 		```Cpp
			> 		#pragma pack(1) //устанавливаем выравнивание на 1
			> 		struct SomeStruct {
			> 			int i;
			> 			char ch;
			> 		};
			> 		#pragma pack //отменяем выравнивание
			> 		
			> 		int main() {
			> 		printf("%d\n", sizeof(struct SomeStruct));
			> 		
			> 		return 0;
			> 		}
			>		```
		    > 	- Пример с `alignas`:  
		    > 		```Cpp
		    > 		struct alignas(16) Vec4 {
		    > 			float x, y, z, w;
		    > 		};
		    > 		```
		    > 		- `alignas(N)` задает выравнивание вручную:
		    > 		- `alignof(T)` возвращает требуемое выравнивание типа.
		    > 	  
		    > ***<u>Заключение:</u>***
		    > Выравнивание критично для производительности, особенно в высокопроизводительных приложениях. Следует учитывать паддинг и правильно упорядочивать поля структур для экономии памяти.
		    
		3. **`#pragma warning`**: Включает или отключает предупреждения (например, в Visual Studio):
			```Cpp
			#pragma warning(disable: 4996) // Игнорировать предупреждение о устаревшей функци
			```
- <u>Директивы **`#ifndef`** и **`#define`**</u>:
	Данные директивы используются в языке **C++** для защиты заголовочных файлов от **множественного включения** <mark>multiple inclusion</mark>. Это **предотвращает ошибки компиляции**, связанные с повторным определением одних и тех же функций, классов или переменных и **ускоряет компиляцию** (Защита предотвращает многократную обработку одного и того же кода).

	***<u>Особенности:</u>***
	1. Макрос называют именем данного заголовочного файла, но только в `high_snake_case`, например:
	   `header_math.h` -> `HEADER_MATH_H`
	   
	2. **`#ifndef 'имя макроса'`**  
	    Проверяет, не был ли ранее определён макрос `'имя макроса'`. Если **не был** — компилятор обрабатывает код внутри блока.  
	    Если **был** — весь блок до `#endif` игнорируется.
    
	2. **`#define 'имя макроса'`**  
	    Определяет макрос `'имя макроса'`, чтобы при повторном включении файла условие `#ifndef` стало ложным, и код не дублировался.

	***<u>Пример:</u>***
	```Cpp
	#ifndef HEADER_MATH_H
	#define HEADER_MATH_H
	
	int add(int a, int b);
	
	#endif
	```

## Компилятор
- На вход компилятору поступает код на ***C++*** после обработки препроцессором.
- Каждый файл с кодом компилируется **отдельно** и **независимо** от других файлов с кодом.
- Компилируется только файлы с кодом (т.е. ***`.cpp`***).
- Заголовочные файлы сами по себе ни во что не компилируются, только в составе файлов с кодом.
- На выходе компилятора из каждого файла с кодом получается **“объектный файл”** - *бинарный* файл со скомпилированным кодом (с расширением `.o` или `.obj`).

***<u>Пример:</u>***
- Код на **C++**:
	```Cpp
	void increment( int& v) {
		v++;
	}

	int add(int a, int b) {
		return a + b;
	}

	int main(int, char**) {
		int x = 1;
		int y = 2;

		increment(y);
		int result = add(x, y);

		return 0;
	}
	```
- Код на **Assmebly**:
	```asm
		.text
	    .globl  _Z9incrementRi        # -- Begin function _Z9incrementRi
	    .p2align    4, 0x90
	    .type   _Z9incrementRi,@function
	_Z9incrementRi:                    # @_Z9incrementRi
	    .cfi_startproc
	# %bb.0:
	
		pushq   %rbp
	    .cfi_def_cfa_offset 16
	    .cfi_offset %rbp, -16
	    movq    %rsp, %rbp
	    .cfi_def_cfa_register %rbp
	    movq    %rdi, -8(%rbp)
	    movq    -8(%rbp), %rax
	    movl    (%rax), %ecx
	    addl    $1, %ecx
	    movl    %ecx, (%rax)
	    popq    %rbp
	    .cfi_def_cfa %rsp, 8
	    retq
	.Lfunc_end1:
	    .size   _Z9incrementRi, .Lfunc_end1-_Z9incrementRi
	    .cfi_endproc
	                                        # -- End function
	main:                                   # @main
	    .cfi_startproc
	
	# %bb.0:
		pushq   %rbp
	    .cfi_def_cfa_offset 16
	    .cfi_offset %rbp, -16
	    movq    %rsp, %rbp
	    .cfi_def_cfa_register %rbp
	    subq    $48, %rsp
	    movl    $0, -4(%rbp)
	    movl    %edi, -8(%rbp)
	    movq    %rsi, -16(%rbp)
	    movl    $1, -20(%rbp)
	    movl    $2, -24(%rbp)
	    leaq    -24(%rbp), %rdi
	    callq   _Z9incrementRi
	```

### Все этапы:
1. **Препроцессинг**  
	- Обработка директив `#` (`#include`, `#define`, `#ifdef` и т.д.).  
	- Удаление комментариев. 
	- Результат: файл с расширением `.i` или `.ii`.

2. **Лексический анализ (Токенизация)**  
	- Исходный код разбивается на токены:  
	  `int x = 5;` → `int`, `x`, `=`, `5`, `;`

3. **Синтаксический анализ (Парсинг)**  
	- Построение **абстрактного синтаксического дерева (AST)**.  
		> Абстрактное синтаксическое дерево <mark>Abstract Syntax Tree</mark> - это древовидная структура, которая представляет синтаксическую структуру исходного кода программы в абстрактной форме.
		>
		> ***<u>Основные особенности AST:</u>***
		> - **Абстракция**: AST опускает несущественные для анализа детали, такие как скобки, запятые, пробелы и комментарии.
		> - **Иерархическая структура**: Узлы дерева представляют операторы, выражения и другие элементы кода.
		> - **Используется в компиляторах и интерпретаторах**: Позволяет анализировать, оптимизировать и трансформировать код.
		>
		> ***<u>Пример AST:</u>***
		> ```Cpp
		> x = a + b * 2;
		> ```
		> AST для этого выражения может выглядеть так:
		> ```Cpp
		>    =
		>   / \
		>  x   +
		>     / \
		>    a   *
		>       / \
		>      b   2
		> ```

	- Проверка грамматики (скобки, точки с запятой, структура кода).

4. **Семантический анализ**  
	- Проверка типов данных и областей видимости.  
	- Примеры ошибок:  
	  - `Переменная не объявлена`  
	  - `Несовместимые типы`

5. **Генерация промежуточного кода**  
	- Преобразование AST в платформонезависимый код (например, LLVM IR).

6. **Оптимизация**  
	- Улучшение кода:
	  - Удаление мёртвого кода.
	  - Свёртка констант (`2 + 3` → `5`).  
	  - Инлайнинг функций.
		  > **Инлайнинг функций** — это оптимизация, при которой вызов функции **заменяется ее телом** прямо в месте вызова. Это позволяет **избежать затрат на вызов функции** (сохранение стекового кадра, передача аргументов и возврат значения).
		  > 
		  > Для объявления inline-функции в C++ используется клювчевое слово `inline`:
		  > ```Cpp
		  > inline int square(int x) {
		  > 	return x * x;
		  > }
		  > 
		  > int main() {
		  > 	int result = square(5); // Компилятор подставит return 5 * 5;
		  > }
		  > ```
		  > Компилятор **может проигнорировать `inline`**, если:
		  > - Функция **слишком большая**.
		  > - Инлайнинг приведет к **увеличению размера бинарного кода**.
		  > - Используется **рекурсия** (обычно не инлайнится).

7. **Генерация ассемблерного кода**  
	- Создание кода для целевой архитектуры (x86, ARM):  
	  ```asm
	  mov eax, 5
	  add eax, 10
	  ```
	- Результат: файл с расширением `.s`.
8. **Ассемблирование**
	- Ассемблерный код переводится в **машинный код** (бинарный формат), формируя объектные файлы (`.o` или `.obj`). Каждый файл содержит код и метаданные для линковки.
	- Результат: файл с расширением `.o` или `.obj`.

9. **Линковка <mark>Linking</mark>**
	- Объединение объектных файлов и статических библиотек в **исполняемый файл** (например, `.exe` или `.so`):
		- Разрешение внешних ссылок (например, вызовов функций из других файлов).
		- Настройка адресов в памяти.
		- Добавление стандартной библиотеки C++ (если требуется).
			> Во время **линковки** на места вызовов функций вставляются ссылки на места хранения этих функций в памяти.
		- Результат: файл с расширением `.exe` или `.so` и тд.

