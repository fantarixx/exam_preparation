### Compilation
> 10. Компиляция, этапы, ошибки компиляци

Программы состоят из файлов. Для чего прграмму разбивают на файлы:
- Логическое разбиение на модули (легче работать с кодом)
- Повторное использование некоторых кусков кода
- Ускорение процесса компиляции
- Небольшие файлы проще читать и редактировать
- Есть два типа файлов
	- Заголовочные (*.h , *.hpp)
	- С исходным кодом (*.cpp)

> Заголовочные файлы в языке программирования C++ содержат объявления функций, классов и переменных, позволяя разделять интерфейс и реализацию кода.
> 
   Файлы кода содержат исходный код, написанный на объектно-ориентированном языке программирования C++.

<br>

### Трансляция программы
- ***Определения:***
 1. ***<u>Трансляция</u>*** <mark>translation</mark>- преобразование программы, представленной на одном из языков программирования (**исходный язык** <mark>source language</mark>), в программу на другой язык (**целевой язык** target <mark>language</mark>) и, в определённом смысле, равносильную первой.
 2. ***<u>Транслятор</u>*** <mark>translator</mark> - программа или устройство, которое выполняет трансляцию.
 3. ***<u>Исходный код</u>*** <mark>source code</mark> - фрагмент текста, написанный на исходном языке для некоторого транслятора, “программа” как текст.
 4. ***<u>Единица трансляции</u>*** <mark>translation unit</mark> - файл исходного кода, обрабатываемый транслятором как единое целое. В случае языка C++ единица трансляции (файл .cpp) является модулем.
 5. ***<u>Интерпретация</u>*** <mark>interpreting</mark> - построчный анализ, обработка и выполнение исходного кода программы или запроса.
 6. ***<u>Интерпретатор</u>*** <mark>interpreter</mark>:
	 - программа или устройство, которое выполняет интерпретацию.
	 - транслятор, целевым языком которого является множество действий.  
7. ***<u>Компиляция</u>*** <mark>compilation</mark>:
  - преобразование программы, представленной на одном из языков програмирования в программу на более низком коде, близком к машинному, который может быть непосредственно выполнен процессором.
  - трансляция, результатом которой является машинный код, который может  быть непосредственно выполнен процессором. 
  - трансляция, результатом которой является файл на нектором целевом языке. В ряде случаев этот файл готов к запуску в некоторой среде исполнения (операционной системе или на виртуальной машине). В дургих случаях требуется компановка (процесс связывания с другими фрагментами кода).
8. ***<u>Компилятор</u>*** <mark>compiler</mark> - программа или устройство, которое выполняет компиляцию.
>Если для компилятора помимо собственно целевого языка имеет значение способ оформления результирующих файлов и иные особенности операционной среды (обычно задаваемые выбором целевой ОС), то говорят о **целевой платформе**. Если целевая платформа не совпадает (не является надмножеством) платформы, на которой запущен сам компилятор, то процесс такой компиляции называется **кросс-компиляцией** (например, на GNU/Linux компилируется код, который будет затем запускаться на Windows).

9. ***<u>Раздельная компиляция</u>*** <mark>separate compilation</mark> - компиляция единиц трансляции по отдельности независимо друг от друга (в произвольном порядке, в том числе параллельно). Какая-то часть из них может быть откомпилирована заранее. В случае C++ это означает независимую компиляцию разных .cpp файлов, включенных в проект. Когда все единицы трансляции скомпилированы, можно выполнить их компоновку в конечный продукт — например, исполняемый файл.
10. ***<u>Ассемблер</u>*** <mark>assembler</mark> - транслятор, исходным языком которого является стандартизованная текстовая форма машинного кода (удобного для человека, - **ассемблерный код** <mark>assembly</mark>), а целевым языком — машинный код.
> Ассемблер можно считать видом компилятора, но традиционно термин “компилятор” применяется только по отношению к трансляторам с исходных языков высокого уровня.

11. ***<u>Дизассемблер</u>*** <mark>disassembler</mark> - ранслятор, исходным языком которого является машинный код, а целевым языком — ассемблерный код. Дизассемблеры, как правило, принимают на вход исполняемые файлы и библиотеки в машинном коде.
12. ***<u>Объектный файл</u>*** <mark>object</mark> - результат работы компилятора в случае использования отдельной программы-компоновщика. Как правило, содержит специальным образом оформленный машинный код (**объектный код** <mark>object code</mark>).
> **“Object code”** тоже можно перевести как “целевой код”, и он действительно является целевым для компилятора. Однако такой перевод может вызвать путаницу с точки зрения разделения “целевого языка” вообще или фрагмента программы на этом языке и промежуточного файла, принимаемого компоновщиком (см. ниже) — “объекта”.
> 
> Исторически слово “object”, вероятно, связано с языком [BCPL](https://ru.wikipedia.org/wiki/BCPL), который можно считать предком языка C. Компилятор BCPL транслировал программы на BCPL в файлы на специальном промежуточном языке низкого уровня [O-code](https://en.wikipedia.org/wiki/O-code) (“object code” — “целевой код”), которые уже затем могли транслироваться в исполняемые файлы для конкретных ОС и процессоров отдельными трансляторами. Такой подход облегчал перенос компилятора на новые системы: сам компилятор можно было не трогать, достаточно было обновить (или написать новый) транслятор O-code. [Данный подход](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B9%D1%82-%D0%BA%D0%BE%D0%B4) затем применялся неоднократно (например, для Pascal, Basic, Java, .NET).

13. ***<u>Машинный код</u>*** <mark>machine code</mark> - язык, интерпретатором которого является некоторый процессор (“машина”).
14. ***<u>Компановка</u>*** <mark>linking</mark> - построение готового к запуску исполняемого файла, либо стандартным образом оформленной библиотеки в машинном коде из набора объектных файлов, библиотек в машинном коде, а также любых дополнительных данных. 
15. ***<u>Компоновщик</u>*** <mark>linker</mark> - программа, выполняющая компановку.
16. ***<u>Исполняемый файл</u>*** <mark>executable</mark> - оформленная в виде файла стандартного формата (для определённой ОС) программа в машинном коде, которую можно немедленно запустить на исполнение.
> - В ОС Windows исполняемые файлы традиционно помечаются разрешением **exe**.
>  - В maxOC и iOS используется формат **Mach-O**.
>  - В Linux нет расширений файлов, но для удобства исполняемые файлы помечаются разрешением **exe**.

17. ***<u>Модуль</u>*** <mark>module</mark>:
	- Специальным образом оформленная единица исходного кода, задающая свою область видимости. Во многих языках (включая C, с той поправкой, что интерфейс модуля предоставляется в виде отдельного заголовочного файла) совпадает с файлом исходного кода и единицей трансляции. Такой модуль может иметь имя, доступное из программы (например, юнит в Pascal, в C — просто имя заголовочного файла, используемое в директиве include).
	- Единица трансляции.
	- В операционных системах: стандартным образом оформленный машинный код (набор процедур), возможно, с внедрёнными данными — **ресурсами** <mark>resources</mark>. Исполняемый файл и динамически связываемая библиотека — примеры модулей.
18. ***<u>Сборка</u>*** <mark>building</mark> - полный многоэтапный процесс порождения исполняемых файлов (модулей) из файлов исходного кода, библиотек и файлов ресурсов.
> Необходимый для сборки конкретный набор программ называют (это распространённый жаргонизм) **тулчейном** <mark>toolchain</mark>. Обычно это компилятор и компоновщик. Нередко в состав тулчейна добавляют отладчик. Естественно, отладчик не задействуется в процессе сборки непосредственно, однако, если мы хотим эффективно применять некоторый отладчик к результирующему машинному коду, то поддержка этого отладчика должна быть заложена уже на этапе сборки. Конкретные реализации стандартных библиотек также могут включаться в тулчейн (просто потому, что любая реализация языка обязана поддерживать его стандартную библиотеку).
	
19. ***<u>Объявление</u>*** <mark>declaration</mark> - языковая конструкция, заявляющая о наличии среди используемых в сборке единиц трансляции и библиотек некоторой сущности (глобальной переменной, функции, типа) и предоставляющая компилятору необходимый минимум сведений об этой сущности.
> В частности, объявление функции состоит из заголовка функции, что позволяет компилятору оформить вызов функции в объектном коде. А уже на этапе компоновки будет достаточно проставить реальный адрес вызываемой функции.

20. ***<u>Определение</u>*** <mark>definition</mark> - полное описание некоторой сущности (переменной, функции, типа) на языке программирования.
21. ***<u>Правило одного определения</u>*** <mark>one definition rule, ODR</mark> в C++:
	1. Любая глобальная сущность может быть определена лишь однажды.
	2. Любая локальная сущность может быть определена лишь однажды в своей области видимости.
	> Программа, нарушающая первую часть ODR может быть скомпилирована без ошибок, но привести к ошибкам компоновки. Программа, нарушающая вторую часть ODR приведёт к ошибкам компиляции.
	
22. ***<u>Библиотека</u>*** <mark>library</mark> -  самостоятельный фрагмент кода, предназначенный для использования в составе другого ПО.
> Библиотека может существовать как в исходном коде, подключаемом во время компиляции и транслируемом вместе с кодом ПО, использующего библиотеку, так и в специально оформленном машинном коде (“модуле”), подключаемом либо во время компоновки (**статические библиотеки** <mark>static libraries</mark>), либо во время работы ПО (**динамически связываемые библиотеки** <mark>dynamically linked libraries, DLL</mark>, <mark>shared objects, SO</mark>).

23. ***<u>Точка входа</u>*** <mark>entry point</mark> - адрес в модуле (исполняемом файле или библиотеке), с которого можно начать выполнение кода.
> Адрес может иметь символическое имя, записанное в специальной таблице внутри модуля. Часто это имя просто совпадает с именем соответствующей функции в исходном коде. В C++ определена стандартная точка входа для исполняемых файлов — функция main.

### Этапы трансляции
| Основные этапы:                                                      | Пример                                                   |
|----------------------------------------------------------------------|----------------------------------------------------------|
| 1. Препроцессор<br>2. Компоновщик<br>3. Линковщик                   | ![Пример трансляции](./src/translation.png)          |

Каждый этап разбивается на подпроцессы, и всего получается 9 этапов.
